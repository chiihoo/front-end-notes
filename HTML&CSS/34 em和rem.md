**em是根据使用它的元素的字体大小决定的**
  * 有些人误以为是根据父元素字体大小决定，只是因为忽视了字体大小可以继承这一机制
  * **1em = 当前元素字体大小，例如16px**

  * 需要转换的像素值px / 当前元素的font-size = 要得出的em值

---

**rem是根据html根目录下的字体大小决定的**
  * **1rem = html根目录下的字体大小，例如15px**
  * X rem = 100vw
    1 rem = (100vw / X)
    html {font-size: calc(100vw / X)}
    其中X设置为视觉稿宽度，比如为1300px，X=1300，
    1rem = 100vw / 1300

    最后使用的时候，直接使用视觉稿上的宽度+rem，比如视觉稿上为100px,那么就直接写100rem,
    100rem = 100 * 100vw/1300 = 100vw/13
    相当于 100vw * (100px/1300px)

    例子：如果设计稿上是以手机屏幕宽300px设计的，现在要适配到屏幕宽400px的设备上，也就是原来宽30px的盒子，适配过去后需要宽为40px。其实就跟百分比的效果差不多。（见34.1移动端举例）

  * rem是基于html元素的字体大小（默认16px）去计算，从而实现对移动端的响应。
    百分比是相对于父元素去计算，在实际使用中，百分比并不是很好用。

    **改进：
    Chrome浏览器不允许最小字号小于12px，而上面的公式算出来的值过小，会被重置，所以将其放大100倍，即
    html {font-size: calc(100vw / X * 100)}
    最后使用的时候，直接使用视觉稿上的宽度(/100)+rem，比如视觉稿上为100px,那么就直接写100/100=1rem**

    有些浏览器不支持calc/vw，所以这个值通过js读取出浏览器视口的宽度并自行算出，然后设置到html元素上，之后从视觉稿量出来的尺寸将小数点移动两位后加rem单位即可用在代码里。

  * 就是把**窗口宽度/视觉稿宽度（*100）**，把结果设置到**html上的font-size**，之后**就可以直接使用视觉稿上的宽度(/100)+rem**，而不用换算。