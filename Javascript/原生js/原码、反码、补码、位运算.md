* 两个数做加法时，先把它们写成补码二进制形式，相加完，再转化为原码二进制形式，即为结果
* 正数的反码，补码都是它自己
* 负数的反码为 在其原码的基础上，符号位不变，其余位取反
  负数的补码为 在其原码的基础上，符号位不变，其余位取反，再+1
  [+1] = [00000001]原 = [00000001]反 = [00000001]补
  [-1] = [10000001]原 = [11111110]反 = [11111111]补

* 反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上.虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.于是补码的出现, 解决了0的符号以及两个编码的问题.

* 位运算都是用补码算的
  |按位或
  &按位与
  ^按位异或
  ~按位非
  >>按位右移（保留符号位，即左边补1） 
  >>>按位右移（不保留符号位，左边补0）
  <<按位左移（右边总是补0） 
* 左移左边的数字不划掉
* 右移右边溢出的数字要划掉



整数在计算机中的表示
  正数直接表达
  负数用补码表示

  用补码表示的目的是为了把减法转换为加法。

  原理类似于钟表的表盘
  即首尾相连的循环结构
  如对于表盘来说，向前拨动3个刻度的指针，相当于向后拨动9个刻度的指针
  反过来，向后拨动5个刻度相当于向前拨动7个刻度
  于是减5就可以转换为加7
  于是-5用7来表达。

  二进制中也只是周期不一样，周期为2的n次方
  最终的效果即为最左边1bit相当于符号位
  负数用补码表示，补码减1得到反码，反码取反得到原码（由二进制转回十进制时）
  由十进制转入二进制时，先写原码，然后原码取反得到反码，反码加1得到补码，即为负数在内存中的表示。



43 & -37
  0010 1011
  1101 1011‬
->  0000 1011
->  11


110 | -14
	  0110 1110
	  1111 0010
->	1111 1110
->  1111 1101
->  1000 0010
->  -2


-220 >>> 3
    1000 0000 0000 0000 0000 0000 1101 1100
->  1111 1111 1111 1111 1111 1111 0010 0011
->  1111 1111 1111 1111 1111 1111 0010 0100
->  000 1111 1111 1111 1111 1111 1111 0010 0	左补0 正
->	536870884


-220 >> 3
    1000 0000 0000 0000 0000 0000 1101 1100
->  1111 1111 1111 1111 1111 1111 0010 0011
->  1111 1111 1111 1111 1111 1111 0010 0100
->  111 1111 1111 1111 1111 1111 1111 0010 0  左补1 负，转回原码
->  111 1111 1111 1111 1111 1111 1111 0001 1
->  100 0000 0000 0000 0000 0000 0000 1110 0
->  -28


114 << 2
	  0111 0010‬
->  0111 0010‬ 00 
->  456


49 << 3
	  0011 0001
->  0011 0001 000
->  392


84 ^ -66
	  0101 0100
    1011 1110
->  1110 1010	负
->	1110 1001
->  1001 0110
->	-(001 0110)
->	-22
