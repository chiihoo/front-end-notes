零宽断言：匹配两个符号之间的一个位置而不是一个符号（宽度为零）
匹配发生时，光标不会移动，所以可以对同一个位置执行多个零宽断言匹配，只有当每个断言都成功时才可以
有4种零断言：
  (?=expr) 正预测零宽断言，这个位置的右边满足expr
  (?!expr) 负预测零宽断言，这个位置的右边不满足expr
  (?<=expr) 正回顾零宽断言，这个位置的左边满足expr（旧版JS不支持）
  (?<!expr) 负回顾零宽断言，这个位置的左边不满足expr（旧版JS不支持）

^ === /(?<![^])/
$ === /(?![^])/
\b === /(?<=\w)(?=\W)|(?<=\W)(?=\w)|(?<![^])|(?![^])/



match,不考虑正则表达式的lastIndex属性。
  当正则表达式有g标志的时候，匹配出所有能够满足整条正则表达式的内容
  当没g标志的时候，匹配出第一条能满足的内容，同时把分组捕获到的内容也放入结果数组

replace(RegExp|String, String|Function)
  两个参数都是字符串：匹配第一次出现的内容为目标内容
  首参为正则
    次参为字符串，里面的$&,$1,$2是特殊内容，表示匹配到匹配到的内容以及各个分组捕获到的内容
    次参为函数，把整个匹配到的内容以及各分组捕获到的内容传给函数做为参数，把函数返回值插入被替换位置
      有多少次匹配，函数就会调用多少次

re.exec(str)方法
  如果re不带g标志，则完全等同于str.match(re)
  如果re带有g标志，则从str的re.lastIndex位置开始查找，查找成功后把re.lastIndex置为匹配位置的后一个位置
    查找不成功的时候，返回null，把lastIndex置为0

str.split(String|RegExp)
  当参数是字符串时，按字符串把原字符串拆成数组
  当参数为正则时，按正则把原字符串拆成各部分的数组，但是
    当正则里有捕获分组时，分组捕获到的内容也会出现在结果数组的相应位置




作业：实现JSON.parse函数，可以考虑输入的字符中没有任何多余的空白
ParseJSON('{"a":[1,2,3]}') -> {a: [1,2,3]}
ParseJSON('"foobar"') -> "foobar"
ParseJSON('{"a":[1,2,3],"b":true,"c":{"d":1,"e":2.5}}') -> {"a":[1,2,3],"b":true,"c":{"d":1,"e":2.5}}

作业：使用exec函数实现所有其它与正则相关的函数：test,match,split,search,replace。
