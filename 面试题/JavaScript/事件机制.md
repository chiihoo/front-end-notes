```
function handleClick() {
	console.log('click')
}
dom1.addEventListener('click', handleClick, true)

target.addEventListener(type, listener, useCapture)
target.addEventListener(type, listener, options)
第三个参数为useCapture或者options

useCapture为true时是捕获，为false时是冒泡，不写的时候默认为false冒泡

options常用为三个参数，
{
	capture: Boolean,	// 捕获还是冒泡
	once: Boolean, // 为true时，该listener最多只会调用一次
	passive: Boolean // 为true时，listener永远不会调用preventDefault()，如果listener实际调用了这个函数，则客户端会忽略并抛出控制台警告
}

```



注意：
以点击事件为例，点击目标元素

* 事件冒泡，指的是从目标元素上开始触发，一直向外传播，直到到达根元素停止
* 事件捕获，指的是从根元素上开始触发，一直向内传播，直到到达目标元素停止。**需要注意的是，这里事件捕获触发的元素必须是第三个参数为true的元素。**



事件的传播顺序是**先捕获，后冒泡**

**`e.stopPropagation()`为阻止事件的传播过程，包括捕获和冒泡过程**

**`IE9以下：event.cancelBubble = true ` 取消冒泡**

举个例子

```
<div>
  <ul>
    <li></li>
  </ul>
</div>

document.querySelector("div").addEventListener(
	"click", 
	e => {
    console.log("div")
	},
  true
);
 
document.querySelector("ul").addEventListener(
	"click",
  e => {
		console.log("ul")
	}
);
 
document.querySelector("li").addEventListener(
	"click", 
	e => {
		console.log("li")
  } 
	,true
);

当点击li时，会打印什么？
先捕获，后冒泡
也就是说，先在第三个参数为true的元素中进行捕获，
先打印div，再打印li
之后，对第三个参数为false的元素，也就是不写第三个参数的元素，进行冒泡
打印ul
结果为 div li ul


document.querySelector("div").addEventListener(
	"click", 
	e => {
    console.log("div")
    e.stopPropagation() // 添加了这一句会阻止事件的传播过程，包括捕获和冒泡，那会输出什么呢
	},
  true
);
 
document.querySelector("ul").addEventListener(
	"click",
  e => {
		console.log("ul")
	}
);
 
document.querySelector("li").addEventListener(
	"click", 
	e => {
		console.log("li")
  } 
	,true
);

先捕获后冒泡
输出div后e.stopPropagation()阻止了事件的传播过程，则后续都不会输出了
结果为 div
```

