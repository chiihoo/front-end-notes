字符串的search、replace方法都可以用正则

'ss'.search(/\w/)

'ss'.replace(/\w/,'a')



**定义RegExp对象**

```
let reg = new RegExp('_(\w)', 'g')

g：全局匹配、、
i：忽略大小写
m：多行模式

m的意思是：一个字符串无论是否换行只有一个开始^和结尾$，如果采用多行匹配，那么每一个行都有一个^和结尾$。
```



**一些js中的方法**

```
reg.test(字符串) // 返回boolean类型
reg.exec(字符串) // 返回数组，全局匹配下，运行一次只能拿到第一个匹配结果，需多次运行

字符串.match(reg) // 全局匹配下能拿到所有匹配结果，但无法获取分组捕获结果$1,$2之类
字符串.matchAll(reg) // 能拿到所有结果，结果必须用for...of来取，因为它是RegExpStringIterator类型的，遍历一次后也不能获取到了

字符串.replace(reg, '_$1')
字符串.replace(reg, ($0, $1) => '_' + $1)
字符串.search(reg)
```



**reg.exec(str)**

```
let reg = /\[(\d+):(\d+\.\d+)\]/g
let str = '[01:05.26][02:19.16][03:14.30]我们之间的距离好像忽远又忽近'
let matches = reg.exec(str)             // ["[01:05.26]", "01", "05.26"]
注意：当reg加了全局标志，exec一次运行也只能匹配到第一个结果，需要像底下那样反复运行

let matches = reg.exec(str)
while (matches !== null) {
    matches = reg.exec(str)
}
```



**str.match(reg)**

```

let str = '[01:05.26][02:19.16][03:14.30]我们之间的距离好像忽远又忽近'
匹配一次不加g
let matches = str.match(/\[(\d+):(\d+\.\d+)\]/)       // ["[01:05.26]", "01", "05.26"]
全局匹配加g
let matches = str.match(/\[(\d+):(\d+\.\d+)\]/g)      //  ["[01:05.26]", "[02:19.16]", "[03:14.30]"]

注意：全局匹配下match能一次性完成匹配，但是不能获取分组捕获结果$1,$2之类的!
```



**str.matchAll(reg)**

```
let str = '[01:05.26][02:19.16][03:14.30]我们之间的距离好像忽远又忽近'
let matches = str.matchAll(/\[(\d+):(\d+\.\d+)\]/g) 
for(let item of matches){
	console.log(item)
	console.log(item[0]) // 用item[0]来获取匹配到的项
}
// 只能遍历一遍，再次遍历为undefined
["[01:05.26]", "01", "05.26"]
["[02:19.16]", "02", "19.16"]
["[03:14.30]", "03", "14.30"]
```





**下划线转驼峰**

**驼峰转下划线**

```
'foo_bar'.replace(/_(\w)/g, ($0, $1)=> $1.toUpperCase())
'fooBar'.replace(/[A-Z]/g, $0 => '_' + $0.toLowerCase())
```



https://juejin.cn/post/6844903845227659271

| 匹配区间                                       | 正则表达式 |
| ---------------------------------------------- | ---------- |
| 除了换行符之外的任何字符                       | .          |
| 单个数字, [0-9]                                | \d         |
| 除了[0-9]                                      | \D         |
| 包括下划线在内的单个字符，[A-Za-z0-9_]         | \w         |
| 非单字字符，就是除了\w能匹配到的字符以外的字符 | \W         |
| 匹配空白字符,包括空格、制表符、换页符和换行符  | \s         |
| 匹配非空白字符                                 | \S         |

\d：数字

\w：字符



*：0次或多次

+：1次或多次

?：0次或1次

^：开始位置

$：结束位置

| 特别字符 | 描述                                                         |
| :------: | ------------------------------------------------------------ |
|    $     | 匹配输入字符串的**结尾**位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
|   ( )    | 标记一个**子表达式**的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
|    *     | 匹配前面的子表达式**零次或多次**。要匹配 * 字符，请使用 \\*。 |
|    +     | 匹配前面的子表达式**一次或多次**。要匹配 + 字符，请使用 \\+。 |
|    .     | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \\. 。    |
|    [     | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。            |
|    ?     | 匹配前面的子表达式**零次或一次**，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
|    \     | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
|    ^     | 匹配输入字符串的**开始**位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
|    {     | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
|    \|    | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

{x}：x次 

{min, max}：介于min次到max次之间 

{min, }：至少min次 

{0, max}： 至多max次

比如/o{2}/，不能匹配Bob，却能匹配food两个o



| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串**开始**的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串**结尾**的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |





| 回溯查找     | 正则                   | 记忆方式                                           |
| ------------ | ---------------------- | -------------------------------------------------- |
| 引用         | \0,\1,\2 和 $0, $1, $2 | 转义+数字                                          |
| 非捕获括号   | (?:x)                  | 匹配 'x' 但是不记住匹配项，指的是$1,$2这样的匹配项 |
| 先行断言     | x(?=y)                 | 匹配到x仅当后面是y的时候                           |
| 正向否定查找 | x(?!y)                 | 仅当x后面不是y时，才会匹配到x                      |
| 后行断言     | (?<=y)x                | 仅当x前面是y时，才会匹配到x                        |
| 反向否定查找 | (?<!y)x                | 仅当x前面不是y时，才会匹配到x                      |



带<说明是往前面查找



```
var str = 'abc abc 123';
str.replace(/(ab)c/g,'$1g');
// 得到结果 'abg abg 123'
```

如果我们不想子表达式被引用，可以使用**非捕获**正则`(?:regex)`这样就可以避免浪费内存。

```
var str = 'scq000'
str.replace(/(scq00)(0)/, '$1,$2')
// 返回"scq00,0"

var str = 'scq000'.
str.replace(/(scq00)(?:0)/, '$1,$2')
// 返回scq00,$2
// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2
```





凡是以`(?=regex)`包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。

例如`happy happily`这两个单词，我想获得以`happ`开头的副词，那么就可以使用`happ(?=ily)`来匹配。

如果我想过滤所有以`happ`开头的副词，那么也可以采用正则`happ(?!ily)`，就会匹配到`happy`单词的`happ`前缀。


