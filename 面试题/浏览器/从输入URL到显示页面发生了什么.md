1. **构建请求**

   浏览器先构建请求行：

   `GET / HTTP/1.1` 

   请求方式为GET，路径为 / 根路径，HTTP协议版本为1.1

2. **查找缓存**

   在发起网络请求之前，浏览器会检查强缓存，如果命中，直接使用缓存的资源，否则，就进行下一步DNS解析。

   注：为什么不检查协商缓存？因为这是第一次请求，只有在响应之后才会检查协商缓存。

3. **DNS域名解析**

   DNS解析就是把根据域名取获取相应的IP地址，具体过程如下：

   1. 先查是否有相应的域名缓存，有的话直接使用缓存的IP访问。Chrome的DNS缓存过期时间为1分钟。

   2. 如果缓存中没有，则去查找hosts文件，hosts文件里面定义了IP地址和域名的映射关系。

   3. 如果在hosts文件里面没有找到想要解析的域名，则将域名发送到本地DNS服务器进行查找，本地DNS服务器一般指的是各大运营商或者DNS运营商提供的，本身缓存了大量常见域名的IP。

   4. 如果还是找不到，就会去根域名服务器进行查询。根域名服务器收到请求，会返回对应的顶级域名服务器的地址，顶级域名服务器收到请求，又会返回二级域服务器的地址，直到最精确的那台DNS，得到查询结果，最后返回给客户端。

      *比如查询 `www.im.qq.com`，简略描述 DNS 的过程就是，先查询 `com`这个域名的DNS服务器有哪些，然后选一个继续查询`qq`这个子域名的DNS服务器有哪些，再选一个继续查询`im`这个子域名的DNS服务器有哪些，`www`不是域名，查询结束，将查询到的IP地址返回给客户端。*

4. **建立TCP连接**

   Chrome在一个域名之下最多只能保持6个TCP连接，超过6个的话其余请求就需要等待。

   建立TCP连接：通过三次握手，建立客户端与服务端之间的连接。

5. **发送HTTP请求**

   TCP连接建立完毕，客户端可以与服务端进行通信了，即开始发送HTTP请求。浏览器发 HTTP 请求要携带三样东西:**请求行**、**请求头**和**请求体**。

   请求行`GET / HTTP/1.1`这个在第一步就已经构建好了，由`请求方法`、`请求URI`和`HTTP版本协议`组成。

6. **服务端响应**

   网络响应也有三个部分：**响应行**、**响应头**和**响应体**。

   响应行类似`HTTP/1.1 200 OK`，由`HTTP协议版本`、`状态码`和`状态描述`组成。

   响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。
   
   **那么客户端收到了响应的资源之后，TCP连接什么时候关闭呢？**
   
   这时候要判断`Connection字段`，当`Connection: close`时，TCP连接会被断开。而如果HTTP1.1版本，请求头或者响应头包含`Connection: Keep-Alive`，则表示建立了持久连接，TCP连接会一直保持，之后对同一站点的资源请求会复用这个TCP连接。
   
   
   
   **如果响应头中`Content-Type`的值是`text/html`，那么接下来就是浏览器的解析和渲染工作了。**
   
   [浏览器渲染过程学习笔记](https://juejin.im/post/6844904003558440974#heading-1)
   
   [浏览器灵魂之问，请问你能接得住几个？](https://juejin.im/post/6844904021308735502#heading-24)
   
   
   
7. **解析HTML，构建DOM树**

   对HTML词法分析，生成DOM树。

8. **样式计算，解析样式表构建styleSheets对象，还要标准化样式表的属性值，之后计算每个节点的样式**

   浏览器解析CSS文本，需要先将CSS文本转换为浏览器可以理解的结构styleSheets。

   标准化属性值指的是em -> px, blue -> rgb(0, 0, 255), bold -> 700，将有差异的属性值统一单位和度量。

   之后要计算每个节点的样式，样式要继承父级元素，后者要覆盖前者的样式。

9. **构建布局树，确定每个节点的位置坐标**

   DOM树和布局树是相似的，主要区别在于DOM树上包含全部节点，包括不可见节点display: none，但是布局树上只有可见节点。

10. **对布局树进行分层，构建图层树**

   页面会有复杂的交互动画，比如3D动画、元素超出形成滚动条、z-index层叠上下文如何控制显示和隐藏，为了实现这些效果，渲染引擎需要为特定的节点生成对应的图层，最终形成一棵分层树。

11. **渲染引擎根据每个图层生成绘制列表，并将其提交给合成线程**

    渲染引擎将图层的绘制拆分成许多绘制指令，比如先画背景、再描绘边框，然后将绘制指令按顺序组合成绘制列表，并提交给合成线程。

12. **合成线程将图层划分为图块，将图块栅格化为位图**

    当页面很大，视口只占一小部分的时候，全部绘制非常浪费。合成线程会将图层划分为多个256 * 256或者512 * 512大小的图块，合成线程会优先渲染视口附近的图块，并将这些图块交给栅格化线程池生成位图，生成的位图又会交给合成线程，通常栅格化的过程会使用GPU进行加速。将向量图像转换成位图的过程就叫做栅格化。

    位图，就是就是最小单位由像素构成的图，缩放会失真。

13. **合成线程返回`DrawQuad`绘制命令给渲染进程，渲染进程生成页面并显示到显示器上**

    栅格化操作完成后，合成线程会生成一个绘图命令`DrawQuad`，并提交给渲染进程，渲染进程有个叫`viz`的组件，接收到命令后，就将页面内容绘制到内存中，再将这部分内存发送给显卡，显卡有`前缓冲区`和`后缓冲区`，当显卡接收到页面时，会将图像保存到`后缓冲区`，而`前缓冲区`显示更新的图像，显卡以固定的频率交换`前缓冲区`和`后缓冲区`，如此便达到了图像的更新。



-> 构建dom树

-> 构建styleSheets，标准化样式表属性，计算每个节点的样式

-> 构建布局树，计算每个节点的位置坐标

-> 图像分层，构建图层树

-> 渲染引擎根据图层生成绘制列表，提交给合成线程

-> 合成线程将图层划分成不同的图块，并栅格化成位图

-> 合成线程返回DrawQuad绘制命令给渲染进程，生成页面，并显示到显示器

![渲染流水线](https://user-gold-cdn.xitu.io/2019/12/15/16f080ba7fa706eb?imageslim)



   <img src="https://user-gold-cdn.xitu.io/2019/11/24/16e9c1fe97d508ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" style="zoom:80%;" />

   

   浏览器不会等到html文档完全解析完毕，才开始构建布局树。

**js的执行是依赖css样式的，只有在css样式全部下载完才会执行js。**

**如果有外链css，那么js的执行时需要等待外链css下载完**

js的下载和执行会阻塞html的解析



* **为什么外链css要放在html文件的header标签里面，而script标签要放在body的最后面？**

  * 因为html文件是从上往下解析的，外链css如果放在尾部，就需要花费额外的时间来加载解析css，可能dom已经显示了，但没有样式，之后等css解析完毕，dom又有样式了，就会造成页面闪烁。而如果是放在header里面，css的加载解析会与dom的解析同时进行，就不会有影响。

  * 浏览器在解析script标签时，会中断html的解析过程，阻塞dom树的构建，如果外部脚本的加载时间很长，就会导致页面处于假死状态。

    

* **script标签的async和defer**

  * 使用async标志的脚本一旦加载完成就会执行。

    使用defer标志的脚本会在DOMContentLoaded事件之前（dom加载完成时）执行，

  * 多个js脚本时，async不保证按照书写顺序执行，哪个先下载完哪个执行。

    defer会按照js脚本书写顺序执行。

  * 同时使用async和defer标志时，浏览器行为以async标志决定。

    

  async：

  -> 开始解析html

  -> 发现async标志的script 

  -> 继续解析html，并行下载该async标志的js脚本 

  -> js脚本下载完毕，阻塞html的解析，执行js脚本

  -> js脚本执行完毕，继续解析html

  defer：

  -> 开始解析html

  -> 发现defer标志的script 

  -> 继续解析html，并行下载该defer标志的js脚本 

  -> 解析html完毕，开始按顺序执行defer标志的js脚本