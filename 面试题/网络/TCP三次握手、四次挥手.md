**TCP三次握手**

首先是服务端开始监听端口，进入`LISTEN`状态

第一次握手，客户端向服务端发起连接，发送`SYN`，随机生成序列号`seq number=x`，客户端进入`SYN-SENT`状态

第二次握手，服务端收到请求后，返回`SYN`、`ACK`，随机生成序列号`seq number=y`，还有确认应答号`ack`为之前客户端发来的序列号 + 1，服务端进入`SYN-RCVD`状态

第三次握手（可以携带数据），客户端收到回应后，再返回`ACK`，此时的确认应答号为服务端发过来的序列号+1，序列号就为`client_isn+1`,客户端进入`ESTABLISHED`状态，服务端收到后也进入该状态

SYN、ACK这些状态都为1

![](https://gitee.com/chiihooy/pictures-bed/raw/master/img/20210306143049.png)

![](https://user-gold-cdn.xitu.io/2020/2/23/170723de9b8aa08b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**为什么不是两次握手？**

因此这样服务端无法确认客户端是否有接收能力。

如果是两次握手，如果服务端发给客户端的回应丢失掉了，客户端会认为没有建立连接，但服务端却认为建立成功了，这样造成资源的浪费。







比如服务端向客户端发数据，序列号和确认应答号与第三次握手的这两个号相同，客户端收到后，需要发一个确认数据包，序列号为上一个数据包的`ack`，确认应答号为上一个的`seq`+本次数据包的数据大小。







**四次挥手**

客户端向服务端发请求关闭连接的报文，服务端收到后向客户端发一个确认报文，让客户端知道自己收到了，

此时，服务端还是可以发数据的，服务端处理完后，再向客户端发请求，这次是确认关闭了，客户端收到后，等待2MSL，再次向服务端发送回应，此时客户端已经关闭连接，服务端接收到后，也关闭连接。

![](https://user-gold-cdn.xitu.io/2020/2/23/170723e5c0e05829?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**为什么要等待2MSL?**

MSL为报文最大生存时间，任何报文在网络上存在的时间只要超过MSL，就会被丢弃

如果服务端没有收到客户端发送的最后的报文，那它会超时重发一个FIN报文，如果客户端收到了重发的这个报文，则2MSL会被重新计时。客户端发送报文的时间+超时重发报文的时间正好是两段，2MSL可以确保客户端能收到超时重传的报文

**2MSL大概是4分钟**



**为什么不是三次挥手?**

因为在第二次挥手后，服务端可能还要发数据。如果第二次挥手和第三次挥手合并的话，客户端可能会认为自己的发的报文可能没有顺利到达，因而不断重发。





TCP报文头部字段

![](https://user-gold-cdn.xitu.io/2020/2/23/170723f106ff0306?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





半连接队列：服务端发送握手报文后，将请求连接放到半连接队列中

全连接队列：三次握手完成后，服务端将请求连接放到全连接队列中