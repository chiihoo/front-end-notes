`http`是应用层的一种超文本传输协议，传输的数据是未加密的

`http`是无连接，无状态的，每个资源都是通过 `url` 来定位的

**无连接**：连接一次就会断开

**无状态**：服务端无法区分客户端是否为同一个身份





**请求报文**

请求行：请求方法 + URL + 协议               POST   /foo/bar.html   HTTP/1.1

请求头： Content-Type之类的

中间有个空行

请求体：数据部分



**响应报文**

状态行：协议 + 状态码 +状态描述           HTTP/1.1   200   OK

响应头

中间有个空行

响应体：数据部分





GET和POST的区别：

1. GET请求只能进行url编码，POST可以进行多种编码

   ```
   application/x-www-form-urlencoded    url编码
   multipart/form-data					 上传文件
   application/json                     json
   text/xml                             xml
   ```

   

2. GET请求是直接发送，而POST请求如果格式不是application/x-www-form-urlencoded、multipart/form-data或text-plain（纯文本）这三者之一的话，就为非简单请求，跨域时会发送两次，第一次为预检请求
3. GET请求可以被缓存，POST请求不会被缓存
4. GET请求是幂等的，而POST请求每次调用都会创建新的资源









HTTPS是在HTTP的基础上加了**SSL与TLS协议**



首先得清楚对称加密和非对称加密

对称加密是指加密和解密用的是相同的密钥。

非对称加密是指有两把密钥，用A加密的数据包只能用B解密，用B加密的数据包只能用A解密。



所以现在的问题是，客户端与服务端怎样加密数据，才能使传输过后都能相应的解密？



对称加密的过程：

1. 客户端发送给服务器一个随机数client_random与一个加密方法列表
2. 服务器返回给客户端另一个随机数server_random与要用到的加密方法
3. 现在两者都有client_random，server_random和加密方法了，用这三样东西加密得到密钥，就都能加解密了

但是http协议是明文传输的，中间人攻击可以获得这三个参数，从而破解



非对称加密的过程：

服务器手中有一把公钥和一把私钥

1. 客户端发送给服务器一个随机数client_random与一个加密方法列表

2. 服务器返回给客户端另一个随机数server_random、要用到的加密方法、以及公钥
3. 服务器用私钥加密，之后客户端用公钥解密

但这样跟对称加密还是一个问题，密钥必须得在网络上传输，就容易被窃取



划重点 ：

既然公钥容易被窃取，那怎么办呢？

加密用到的是client_random、server_random、加密方法、密钥这四种。只要随机数不同，加密出来的数据包就完全不同了。

解决方法就是客户端新生成一个随机数，用发过来的公钥加密，再发给服务器，用私钥进行解密，之后用这三个随机数、加密方法进行加密，得到密钥。

也就是**用非对称加密来传输一个新的随机数，再生成一个对称加密要用到的密钥**

**或者在本地先加密好了再传给服务器上**



完整流程：

1. 客户端生成一个随机数，将该随机数client_random与一组加密方法列表发送给服务端

2. 服务端有公钥和私钥，它也产生一个新随机数，将该随机数server_random与选定的加密方法，还有公钥，一起发送给客户端
3. 客户端收到后，再生成一个随机数pre_random，将client_random、server_random、pre_random与加密方法，加密得到会话密钥，用公钥加密会话密钥，并发送到服务端
4. 服务端用私钥解密，得到这个会话密钥

但是如果黑客用DNS劫持，将目标地址替换到黑客服务器的地址，然后黑客自己伪造一份公钥和私钥，这样就破解了，因此需要让服务器自证身份。这就用到了数字证书。



**服务器运营者需要向第三方机构CA申请授权，认证通过后，CA会给服务器颁发数字证书**

**这个数字证书中包含了明文信息（签发机构、签发时间之类的，还有服务器的公钥）和hash签名（防止明文信息被篡改），CA用自己的私钥给该内容进行加密**

**解析数字证书的时候，浏览器先验证hash值，确保证书没有被篡改，之后到明文信息中的签发机构中获取CA的公钥，对证书进行解密，获取到签发机构、签发时间、服务器公钥等一系列信息**





**完整流程：**

1. **客户端生成一个随机数，将该随机数client_random与本地支持的加密方法列表发送给服务端**

2. **服务端生成一个新随机数，将该随机数server_random与选定的加密方法，还有数字证书，一起发送给客户端**
3. **客户端收到后，解析数字证书，如果证书没有问题，就生成一个随机数（预主密钥），用client_random、server_random、这个随机数以及选定的加密方法，加密得到会话密钥，用解析数字证书得到的服务器公钥加密会话密钥并发送到服务端**
4. **服务端用私钥解密，得到会话密钥**



```
1. 客户端给出 客户端随机生成的随机数，支持的加密方法列表
2. 服务器确认使用的加密方法，并给出服务器随机生成的随机数，数字证书
3. 客户端确认证书有效，生成一个新的随机数，并用数字证书的公钥加密这个随机数，发给服务端
4. 服务端用自己的私钥，解密得到这个随机数
5. 客户端和服务端用约定的加密方法加密这三个随机数，生成对话密钥
```



